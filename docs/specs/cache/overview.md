# Cache

## Summary

repiq のプロバイダーレスポンスをディスクにキャッシュし、API レート制限の消費を抑えつつ、繰り返しクエリのレスポンスタイムを大幅に短縮する。

## Background & Purpose

repiq は AI エージェントから繰り返し呼び出されるツールとして設計されている。エージェントが複数のライブラリを比較検討するワークフローでは、同一リポジトリ/パッケージへの重複クエリが頻繁に発生する。

現状の課題:

- **レート制限の浪費**: GitHub API は未認証で 60req/hr、認証済みで 5,000req/hr。1 ターゲットあたり複数の API コールが必要なため、比較ワークフローで上限に到達しやすい
- **不要なレイテンシ**: メトリクスは分単位で変動するものではないが、毎回フルフェッチしている。エージェントの思考ループに数秒の待ちが毎回発生する
- **オフライン非対応**: ネットワーク不通時に直近のデータすら返せない

## Why Now

MVP (core + npm) が完了し、基盤が安定した。プロバイダー追加 (P3: registries) の前にキャッシュレイヤーを入れることで、今後のプロバイダーが自動的にキャッシュの恩恵を受けられる。先にやるほど ROI が高い。

## Hypothesis

- **Hypothesis 1**: キャッシュ導入により、キャッシュヒット時のレスポンスタイムが 3 秒未満から 100ms 未満に短縮され、エージェントワークフローの体感速度が改善される
- **Hypothesis 2**: 24 時間 TTL のキャッシュにより、典型的な比較ワークフロー (5-10 ターゲット × 2-3 回参照) で API コール数が 60-70% 削減され、レート制限に到達するリスクが大幅に低下する

## Expected Outcome

- キャッシュヒット時のレスポンスが瞬時 (<100ms) になり、エージェントの思考ループがスムーズに回る
- GitHub API レート制限の消費が抑えられ、大規模な比較ワークフローでも制限に到達しにくくなる
- 将来のプロバイダー追加時にキャッシュ対応が自動的に適用される (プロバイダーレイヤーの下にキャッシュレイヤーを挟む設計)
