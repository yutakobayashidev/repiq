# Requirements: ディスクキャッシュ

## Functional Requirements

### P1 (Must have)

- 同一ターゲット (`scheme:identifier`) への 2 回目以降のクエリで、TTL 内であればディスクキャッシュからレスポンスを返し、API コールを発生させない
- キャッシュ保存先は `os.UserCacheDir()/repiq/` とし、XDG Base Directory 仕様に準拠する
- キャッシュの TTL は 24 時間とする (全プロバイダー共通の固定値)
- `--no-cache` フラグを指定した場合、キャッシュを読まずに API からフェッチし、取得した結果でキャッシュを更新する
- キャッシュヒット時の出力は、キャッシュなしの場合と完全に同一であること (透過性)
- TTL が切れたエントリは読み取り時に無視し、API から再フェッチする (遅延削除)

### P2 (Should have)

- キャッシュストレージ形式は 1 エントリ = 1 JSON ファイルとし、`cached_at` タイムスタンプと `result` ペイロードを含む
- キャッシュファイル名は `scheme:identifier` から一意に導出する (ファイルシステムで安全な文字列に変換)
- キャッシュは既存の全プロバイダー (GitHub, npm) に自動適用される
- 新規プロバイダー追加時にキャッシュ対応のための追加コードが不要な設計にする

### P3 (Nice to have)

- キャッシュディレクトリが存在しない場合、自動的に作成する
- キャッシュファイルの書き込みが失敗しても (ディスクフル等)、フェッチ結果自体は正常に返す

## Non-Functional Requirements

- キャッシュヒット時のレスポンスタイムは 100ms 未満であること
- キャッシュの読み書きは goroutine safe であること (複数ターゲットの並列フェッチで競合しない)
- 外部依存 (サードパーティライブラリ) を追加しない。Go 標準ライブラリのみで実装する

## Edge Cases

1. **キャッシュディレクトリが存在しない**: 初回実行時に自動作成。作成失敗時はキャッシュなしで動作を継続
2. **キャッシュファイルの JSON が壊れている**: 手動編集やディスク障害で JSON が不正な場合、キャッシュミスとして API から再フェッチ
3. **エラー結果 (`Result.Error` がセットされた Result)**: キャッシュしない。次回は必ず API から再フェッチし、一時的な API 障害の影響が残らないようにする
4. **部分エラー (メトリクスとエラーの両方がある Result)**: キャッシュしない。次回は完全な結果を取得するチャンスを与える
5. **`--no-cache` フラグ使用時**: キャッシュ読み取りをスキップするが、フェッチ結果はキャッシュに書き込む (次回以降のキャッシュヒットに備える)
6. **同一ターゲットへの並列リクエスト**: CLI の現行設計では同一ターゲットが複数指定されることは稀だが、仮に発生しても各 goroutine が独立にキャッシュ読み書きして問題ない (ファイル単位のアトミック書き込みで対応)
7. **`os.UserCacheDir()` が失敗する環境**: HOME 未設定等で失敗する場合、キャッシュなしで動作を継続

## Constraints

- Out of Scope のアイテムを実装しない: `--clear-cache`、インメモリキャッシュ、プロバイダー別 TTL、LRU eviction、`cached_at` の JSON 出力、ステイルキャッシュフォールバック
- キャッシュレイヤーはプロバイダーインターフェース (`provider.Provider`) のデコレーターとして実装し、既存のプロバイダーコードを変更しない
- キャッシュファイルのアトミック書き込み (一時ファイル → rename) でデータ破損を防ぐ
